<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clash Royale Global Scoreboard</title>
<style>
:root{--bg:#0f1221;--card:#151935;--muted:#9aa0b4;--fg:#eaeaf2;--accent:#6ea8fe}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#0d1020 0%,#0f1221 100%);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
.container{max-width:980px;margin:32px auto;padding:0 16px}
h1{font-size:28px;margin:0 0 16px;text-align:center}
.topbar{display:grid;grid-template-columns:1fr auto 1fr auto 1.2fr auto;gap:12px;align-items:center;margin-bottom:20px}
.input{background:var(--card);border:1px solid #222748;border-radius:10px;padding:10px 12px;color:var(--fg);outline:none;min-width:140px}
.button{background:var(--accent);border:none;border-radius:10px;color:#0b1023;padding:10px 14px;font-weight:700;cursor:pointer;transition:transform .06s ease}
.button:active{transform:translateY(1px)}
.button.secondary{background:#222748;color:var(--fg)}
.button.dim{opacity:.55;filter:saturate(.5);cursor:not-allowed}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:14px}
.card{background:var(--card);border:1px solid #222748;border-radius:14px;padding:14px;display:flex;flex-direction:column;gap:12px}
.row{display:flex;justify-content:space-between;gap:8px;align-items:center}
.vs{font-weight:800;letter-spacing:.3px}
.name{font-weight:700}
.score{font-size:34px;font-weight:900}
.controls{display:flex;gap:8px;flex-wrap:wrap;position:relative}
.small{font-size:12px;color:var(--muted)}
.badge{font-size:11px;border:1px solid #2a2f47;border-radius:999px;padding:4px 8px;color:var(--muted)}
.badge.ok{color:#0a1b12;border-color:#1a3a2a;background:rgba(101,212,140,.18)}
.badge.wait{color:#1a203a;border-color:#2a2f47;background:rgba(110,168,254,.16)}
.toolbar{display:flex;gap:6px;flex-wrap:wrap}
hr{border:none;border-top:1px solid #232845;margin:18px 0}
footer{margin:20px 0;color:var(--muted);font-size:12px;text-align:center}
#empty{opacity:.8;text-align:center;padding:40px;border:1px dashed #2a2f47;border-radius:14px}
input[type="search"]{grid-column:1/-1}

/* Centered popup + backdrop */
#toastBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);opacity:0;pointer-events:none;transition:opacity .15s;z-index:9998}
#toastBackdrop.show{opacity:1;pointer-events:auto}
#toast{
  position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
  background:#0f1330;border:1px solid #3a4166;color:var(--fg);
  padding:18px 22px;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.55);
  opacity:0;pointer-events:none;transition:opacity .15s;max-width:92vw;text-align:center;z-index:9999;
  font-size:16px;line-height:1.3
}
#toast.show{opacity:1}
.toast-title{display:block;font-weight:900;margin-bottom:8px;font-size:18px;text-align:center}
.subtitle{font-size:13px;color:var(--muted);text-align:center}

/* Invisible click-catcher during score cooldown (after first +1) */
.cooldown-overlay{
  position:absolute; right:0; top:0;
  width:auto; height:40px;
  display:flex; gap:8px;
  cursor:not-allowed; z-index:2; background:transparent;
}
</style>
</head>
<body>
<div class="container">
  <h1>Clash Royale Global Scoreboard</h1>
  <div class="topbar">
    <input id="a" class="input" placeholder="Player A" />
    <span class="small">vs</span>
    <input id="b" class="input" placeholder="Player B" />
    <span class="small">mode/title</span>
    <input id="t" class="input" placeholder="e.g. Ladder / 2v2 / Draft" />
    <button id="add" class="button">Add Matchup</button>
    <input id="search" class="input" type="search" placeholder="Search matchups" />
  </div>

  <div id="empty" class="small">No matchups yet. Add one above.</div>
  <div id="list" class="grid"></div>

  <hr />
  <footer>A Kushal Sachdeva Production</footer>
</div>

<!-- Centered popup -->
<div id="toastBackdrop"></div>
<div id="toast"></div>

<!-- Firebase CDN (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script>
/* ---------- Firebase init ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyClcpvLfQy4OiiuDhAUxOFqqUgst474tAA",
  authDomain: "clashroyalescore-362e0.firebaseapp.com",
  projectId: "clashroyalescore-362e0",
  storageBucket: "clashroyalescore-362e0.firebasestorage.app",
  messagingSenderId: "764219519441",
  appId: "1:764219519441:web:454f203bcdb3efd3e2b0f0",
  measurementId: "G-1NK8D02HTF"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/* ---------- Constants & helpers ---------- */
const SCORE_COOLDOWN_MS = 120000;  // 2 min for +1
const ARM_WINDOW_MS     = 600000;  // 10 min arm window for reset/delete

const $  = (q)=>document.querySelector(q);
const $$ = (q)=>document.querySelectorAll(q);
const human = (ms)=>{
  const s = Math.ceil(ms/1000); const m = Math.floor(s/60); const r = s%60;
  return m ? `${m}m ${r}s` : `${r}s`;
};
const coll = ()=> db.collection('matchups');

const toast = (msg, title='')=>{
  const el = $('#toast'), bg = $('#toastBackdrop');
  el.innerHTML = title ? `<span class="toast-title">${title}</span>${msg}` : msg;
  bg.classList.add('show'); el.classList.add('show');
  clearTimeout(window.__toastTimer);
  window.__toastTimer = setTimeout(()=>{ el.classList.remove('show'); bg.classList.remove('show'); }, 3000);
};

/* Remaining timers */
const remainingScore = (d)=>{
  const last = d.lastUpdate ? d.lastUpdate.toMillis() : 0;
  return Math.max(0, SCORE_COOLDOWN_MS - (Date.now() - last));
};
const remainingArm = (ts)=>{
  const t = ts ? (ts.toMillis ? ts.toMillis() : ts) : 0;
  return Math.max(0, ARM_WINDOW_MS - (Date.now() - t));
};

/* Live state cache for countdowns */
let __docs = []; // {id,a,b,title,sa,sb,createdMs,lastUpdate,resetArmAt,deleteArmAt}

/* ---------- Actions ---------- */
const addMatchup = async ()=>{
  const a = $('#a').value.trim();
  const b = $('#b').value.trim();
  const title = $('#t').value.trim();
  if (!a || !b) return toast('Enter both player names');

  try{
    // Minimal create payload to work with strict rules
    await coll().add({
      a, b, title,
      sa: 0, sb: 0,
      created: firebase.firestore.FieldValue.serverTimestamp()
    });
    $('#a').value=''; $('#b').value=''; $('#t').value='';
  }catch(err){
    toast(`Create failed: ${err?.message||err}`);
  }
};

const rename = async (id, side, name)=>{
  if (!name || !name.trim()) return;
  try{
    await coll().doc(id).update(side==='a' ? { a: name.trim() } : { b: name.trim() });
  }catch(err){
    toast(`Rename failed: ${err?.message||err}`);
  }
};

const bump = async (id, side)=>{
  const ref = coll().doc(id);
  try {
    const snap = await ref.get(); if (!snap.exists) return;
    const d = snap.data(); const title = d.title || '';
    const rem = remainingScore(d);
    if (rem > 0) {
      // If a score happened before, show cooldown; otherwise stay silent (per your request)
      if (d.lastUpdate) toast(`Cooldown — ${human(rem)} left (anti-tampering)`, title);
      return;
    }

    await db.runTransaction(async (tx)=>{
      const s = await tx.get(ref); if (!s.exists) throw new Error('missing');
      const cur = s.data();
      tx.update(ref, {
        sa: cur.sa + (side==='a'?1:0),
        sb: cur.sb + (side==='b'?1:0),
        lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
      });
    });
    toast('Score added', title);
  } catch (err) {
    toast(`+1 failed: ${err?.message||err}`);
  }
};

const onReset = async (id)=>{
  const ref = coll().doc(id);
  try {
    const snap = await ref.get(); if (!snap.exists) return;
    const d = snap.data(); const title = d.title || '';
    const armed = !!d.resetArmAt; const rem = remainingArm(d.resetArmAt);

    if (!armed) {
      await ref.update({ resetArmAt: firebase.firestore.FieldValue.serverTimestamp() });
      return toast('Reset armed — come back in 10 minutes, then tap Reset again to confirm.', title);
    }
    if (rem > 0) return toast(`Reset armed — ${human(rem)} left before you can confirm.`, title);

    await db.runTransaction(async (tx)=>{
      const s = await tx.get(ref); if (!s.exists) throw new Error('missing');
      tx.update(ref, { sa:0, sb:0, lastUpdate:null, resetArmAt:null });
    });
    toast('Reset complete', title);
  } catch (err) {
    toast(`Reset failed: ${err?.message||err}`);
  }
};

const onDelete = async (id)=>{
  const ref = coll().doc(id);
  try {
    const snap = await ref.get(); if (!snap.exists) return;
    const d = snap.data(); const title = d.title || '';
    const armed = !!d.deleteArmAt; const rem = remainingArm(d.deleteArmAt);

    if (!armed) {
      await ref.update({ deleteArmAt: firebase.firestore.FieldValue.serverTimestamp() });
      return toast('Delete armed — come back in 10 minutes, then tap Delete again to confirm.', title);
    }
    if (rem > 0) return toast(`Delete armed — ${human(rem)} left before you can confirm.`, title);

    await ref.delete();
    toast('Matchup deleted', title);
  } catch (err) {
    toast(`Delete failed: ${err?.message||err}`);
  }
};

/* ---------- UI builders ---------- */
const badge = (cls, text)=> `<span class="badge ${cls}">${text}</span>`;

const cardHTML = (it)=>{
  const scoreRem = remainingScore(it);
  const scoreReady = scoreRem === 0;
  const hasEverScored = !!it.lastUpdate;

  const rRem = remainingArm(it.resetArmAt);
  const rArmed = !!it.resetArmAt;
  const resetLabel = !rArmed ? 'Reset: Tap to arm'
                    : (rRem===0 ? 'Reset: Ready to confirm' : `Reset: Armed — Wait ${human(rRem)}`);

  const dRem = remainingArm(it.deleteArmAt);
  const dArmed = !!it.deleteArmAt;
  const deleteLabel = !dArmed ? 'Delete: Tap to arm'
                     : (dRem===0 ? 'Delete: Ready to confirm' : `Delete: Armed — Wait ${human(dRem)}`);

  return `
  <div class="card" data-id="${it.id}">
    <div class="row">
      <div>
        <div class="vs">
          <span class="name editable" data-side="a">${it.a}</span> vs
          <span class="name editable" data-side="b">${it.b}</span>
        </div>
        ${it.title ? `<div class="subtitle">${it.title}</div>` : ''}
      </div>
      <div class="toolbar">
        ${scoreReady ? badge('ok','Score: Ready') : badge('wait',`Score: Wait ${human(scoreRem)}`)}
        ${!rArmed ? badge('',resetLabel) : (rRem===0 ? badge('ok',resetLabel) : badge('wait',resetLabel))}
        ${!dArmed ? badge('',deleteLabel) : (dRem===0 ? badge('ok',deleteLabel) : badge('wait',deleteLabel))}
      </div>
    </div>

    <div class="row">
      <div class="score">${it.sa} : ${it.sb}</div>
      <div class="controls">
        ${(!scoreReady && hasEverScored) ? `<div class="cooldown-overlay" data-id="${it.id}"></div>` : ``}
        <button class="button ${scoreReady?'':'dim'}" ${scoreReady?'':'disabled'} data-action="plusA">+1 ${it.a}</button>
        <button class="button ${scoreReady?'':'dim'}" ${scoreReady?'':'disabled'} data-action="plusB">+1 ${it.b}</button>
      </div>
    </div>

    <div class="row">
      <div class="small">Last score add: ${it.lastUpdate ? it.lastUpdate.toDate().toLocaleString() : '—'}</div>
      <div class="controls">
        <button class="button secondary" data-action="reset">Reset</button>
        <button class="button secondary" data-action="delete">Delete</button>
      </div>
    </div>
  </div>`;
};

/* Render + wire rename */
const render = (docs)=>{
  __docs = docs;

  const q = $('#search').value.trim().toLowerCase();
  const items = docs
    .filter(x => !q || x.a.toLowerCase().includes(q) || x.b.toLowerCase().includes(q) || (x.title||'').toLowerCase().includes(q))
    .sort((x,y)=> (y.createdMs||0) - (x.createdMs||0));

  $('#list').innerHTML = items.map(cardHTML).join('');
  $('#empty').style.display = items.length ? 'none' : 'block';

  $$('#list .card .editable').forEach(n=>{
    n.addEventListener('click', ()=>{
      const id = n.closest('.card').dataset.id;
      const side = n.getAttribute('data-side');
      const next = prompt('Rename', n.textContent);
      if (next && next.trim()) rename(id, side, next.trim());
    });
  });
};

/* ---------- Realtime + countdown ---------- */
let unsubscribe = null;
const listen = ()=>{
  if (unsubscribe) unsubscribe();
  unsubscribe = coll().orderBy('created','desc').onSnapshot((snap)=>{
    const docs = [];
    snap.forEach(d=>{
      const x = d.data();
      docs.push({
        id: d.id,
        a: x.a, b: x.b, title: x.title || '',
        sa: x.sa, sb: x.sb,
        created: x.created || null,
        createdMs: x.created ? x.created.toMillis() : 0,
        lastUpdate: x.lastUpdate || null,
        resetArmAt: x.resetArmAt || null,
        deleteArmAt: x.deleteArmAt || null
      });
    });
    render(docs);
  });
};

function updateBadges(){
  const map = new Map(__docs.map(x=>[x.id, x]));
  $$('#list .card').forEach(card=>{
    const id = card.dataset.id;
    const it = map.get(id); if (!it) return;

    // Score badge + button state
    const sRem = remainingScore(it), scoreReady = sRem === 0, hasEverScored = !!it.lastUpdate;
    const badges = card.querySelectorAll('.toolbar .badge');
    if (badges[0]) badges[0].outerHTML = scoreReady
      ? '<span class="badge ok">Score: Ready</span>'
      : `<span class="badge wait">Score: Wait ${human(sRem)}</span>`;

    const btnA = card.querySelector('[data-action="plusA"]');
    const btnB = card.querySelector('[data-action="plusB"]');
    if (btnA && btnB) {
      btnA.classList.toggle('dim', !scoreReady);
      btnB.classList.toggle('dim', !scoreReady);
      btnA.toggleAttribute('disabled', !scoreReady);
      btnB.toggleAttribute('disabled', !scoreReady);
    }

    // Overlay for cooldown only if at least one score happened
    const controls = card.querySelector('.controls');
    let ov = controls.querySelector('.cooldown-overlay');
    if (!scoreReady && hasEverScored) {
      if (!ov) { ov = document.createElement('div'); ov.className='cooldown-overlay'; ov.setAttribute('data-id', id); controls.prepend(ov); }
    } else if (ov) ov.remove();

    // Reset badge
    const rRem = remainingArm(it.resetArmAt), rArmed = !!it.resetArmAt;
    const resetHTML = !rArmed
      ? '<span class="badge">Reset: Tap to arm</span>'
      : (rRem===0 ? '<span class="badge ok">Reset: Ready to confirm</span>' : `<span class="badge wait">Reset: Armed — Wait ${human(rRem)}</span>`);
    if (badges[1]) badges[1].outerHTML = resetHTML;

    // Delete badge
    const dRem = remainingArm(it.deleteArmAt), dArmed = !!it.deleteArmAt;
    const deleteHTML = !dArmed
      ? '<span class="badge">Delete: Tap to arm</span>'
      : (dRem===0 ? '<span class="badge ok">Delete: Ready to confirm</span>' : `<span class="badge wait">Delete: Armed — Wait ${human(dRem)}</span>`);
    if (badges[2]) badges[2].outerHTML = deleteHTML;
  });
}

/* ---------- Global delegated clicks (never breaks on re-render) ---------- */
document.addEventListener('click', async (e) => {
  // cooldown overlay click -> show cooldown
  const ov = e.target.closest('.cooldown-overlay');
  if (ov) {
    const id = ov.getAttribute('data-id');
    const it = (__docs||[]).find(x=>x.id===id);
    if (it) {
      const rem = remainingScore(it);
      const title = it.title || '';
      if (rem > 0) toast(`Cooldown — ${human(rem)} left (anti-tampering)`, title);
    }
    return;
  }

  // buttons
  const btn = e.target.closest('[data-action]');
  if (!btn) return;
  const card = btn.closest('.card'); if (!card) return;
  const id = card.dataset.id;

  try {
    switch (btn.dataset.action) {
      case 'plusA': await bump(id,'a'); break;
      case 'plusB': await bump(id,'b'); break;
      case 'reset': await onReset(id); break;
      case 'delete': await onDelete(id); break;
    }
  } catch (err) {
    toast(String(err?.message||err));
  }
});

/* ---------- Wire up page ---------- */
$('#add').addEventListener('click', addMatchup);
$('#a,#b,#t').addEventListener('keydown', (e)=>{ if (e.key==='Enter') addMatchup(); });
$('#search').addEventListener('input', listen);

listen();
setInterval(updateBadges, 1000);
</script>
</body>
</html>
