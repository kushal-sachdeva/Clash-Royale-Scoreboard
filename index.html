<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clash Royale Global Scoreboard</title>
<style>
:root{--bg:#0f1221;--card:#151935;--muted:#9aa0b4;--fg:#eaeaf2;--accent:#6ea8fe}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#0d1020 0%,#0f1221 100%);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
.container{max-width:980px;margin:32px auto;padding:0 16px}
h1{font-size:28px;margin:0 0 16px}
.topbar{display:grid;grid-template-columns:1fr auto 1fr auto 1.2fr auto;gap:12px;align-items:center;margin-bottom:20px}
.input{background:var(--card);border:1px solid #222748;border-radius:10px;padding:10px 12px;color:var(--fg);outline:none;min-width:140px}
.button{background:var(--accent);border:none;border-radius:10px;color:#0b1023;padding:10px 14px;font-weight:700;cursor:pointer;transition:transform .06s ease}
.button:active{transform:translateY(1px)}
.button.secondary{background:#222748;color:var(--fg)}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:14px}
.card{background:var(--card);border:1px solid #222748;border-radius:14px;padding:14px;display:flex;flex-direction:column;gap:12px}
.row{display:flex;justify-content:space-between;gap:8px;align-items:center}
.vs{font-weight:800;letter-spacing:.3px}
.name{font-weight:700}
.score{font-size:34px;font-weight:900}
.controls{display:flex;gap:8px}
.small{font-size:12px;color:var(--muted)}
.badge{font-size:11px;border:1px solid #2a2f47;border-radius:999px;padding:4px 8px;color:var(--muted)}
.badge.ok{color:#0a1b12;border-color:#1a3a2a;background:rgba(101,212,140,.18)}
.badge.wait{color:#1a203a;border-color:#2a2f47;background:rgba(110,168,254,.16)}
.badge.warn{color:#2b0e11;border-color:#3a1a1e;background:rgba(240,113,120,.2)}
.toolbar{display:flex;gap:6px;flex-wrap:wrap}
hr{border:none;border-top:1px solid #232845;margin:18px 0}
footer{margin:20px 0;color:var(--muted);font-size:12px;text-align:center}
#empty{opacity:.8;text-align:center;padding:40px;border:1px dashed #2a2f47;border-radius:14px}
input[type="search"]{grid-column:1/-1}
.hidden{display:none}

/* Centered popup */
#toast{
  position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
  background:#151935;border:1px solid #2a2f47;color:var(--fg);
  padding:16px 20px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,.35);
  opacity:0;pointer-events:none;transition:opacity .15s ease;max-width:92vw;text-align:center;z-index:9999
}
#toast.show{opacity:1}
.toast-title{display:block;font-weight:800;margin-bottom:6px}
.subtitle{font-size:13px;color:var(--muted)}
.title{font-weight:700}
</style>
</head>
<body>
<div class="container">
  <h1>Clash Royale Global Scoreboard</h1>
  <div class="topbar">
    <input id="a" class="input" placeholder="Player A" />
    <span class="small">vs</span>
    <input id="b" class="input" placeholder="Player B" />
    <span class="small">mode/title</span>
    <input id="t" class="input" placeholder="e.g. Ladder / 2v2 / Draft" />
    <button id="add" class="button">Add Matchup</button>
    <input id="search" class="input" type="search" placeholder="Search matchups" />
  </div>
  <div id="empty" class="small">No matchups yet. Add one above.</div>
  <div id="list" class="grid"></div>
  <hr />
  <footer>A Kushal Sachdeva Production</footer>
</div>
<div id="toast"></div>

<!-- Firebase CDN -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script>
  /* === Firebase init (your real config) === */
  const firebaseConfig = {
    apiKey: "AIzaSyClcpvLfQy4OiiuDhAUxOFqqUgst474tAA",
    authDomain: "clashroyalescore-362e0.firebaseapp.com",
    projectId: "clashroyalescore-362e0",
    storageBucket: "clashroyalescore-362e0.firebasestorage.app",
    messagingSenderId: "764219519441",
    appId: "1:764219519441:web:454f203bcdb3efd3e2b0f0",
    measurementId: "G-1NK8D02HTF"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  /* === Constants & helpers === */
  const SCORE_COOLDOWN_MS = 120000;   // 2 min
  const ACTION_WINDOW_MS  = 600000;   // 10 min (two-tap window for reset/delete)

  const $  = q => document.querySelector(q);
  const $$ = q => document.querySelectorAll(q);
  const human = (ms) => {
    const s = Math.ceil(ms/1000); const m = Math.floor(s/60); const r = s%60;
    return m ? `${m}m ${r}s` : `${r}s`;
  };
  const coll = () => db.collection('matchups');

  /* centered popup with matchup title in first line if present */
  const toast = (msg, title) => {
    const el = $('#toast');
    el.innerHTML = title ? `<span class="toast-title">${title}</span>${msg}` : msg;
    el.classList.add('show');
    setTimeout(()=>el.classList.remove('show'), 2000);
  };

  /* remaining timers */
  const remainingScore = (d) => {
    const last = d.lastUpdate ? d.lastUpdate.toMillis() : 0;
    return Math.max(0, SCORE_COOLDOWN_MS - (Date.now() - last));
  };
  const remainingArm    = (ts) => {
    const t = ts ? (ts.toMillis ? ts.toMillis() : ts) : 0;
    return Math.max(0, ACTION_WINDOW_MS - (Date.now() - t));
  };

  /* derive readable state for badges */
  const resetState  = (d) => {
    const armed = !!d.resetArmAt;
    const rem   = remainingArm(d.resetArmAt);
    return { armed, rem, ready: armed && rem === 0 };
  };
  const deleteState = (d) => {
    const armed = !!d.deleteArmAt;
    const rem   = remainingArm(d.deleteArmAt);
    return { armed, rem, ready: armed && rem === 0 };
  };
  /* === Actions: add, +1, two-tap reset/delete === */

  const addMatchup = async () => {
    const a = $('#a').value.trim(), b = $('#b').value.trim(), title = $('#t').value.trim();
    if (!a || !b) return toast('Enter both player names');
    await coll().add({
      a, b, title,
      sa: 0, sb: 0,
      created: firebase.firestore.FieldValue.serverTimestamp(),
      lastUpdate: null,
      resetArmAt: null,
      deleteArmAt: null
    });
    $('#a').value=''; $('#b').value=''; $('#t').value='';
  };

  const bump = async (id, side, metaTitle) => {
    const ref = coll().doc(id);
    const snap = await ref.get();
    if (!snap.exists) return;
    const d = snap.data();
    const rem = remainingScore(d);
    if (rem > 0) return toast(`Wait ${human(rem)} before adding (+1) — anti-tampering`, metaTitle);

    await db.runTransaction(async (tx) => {
      const s = await tx.get(ref); if (!s.exists) throw new Error('missing');
      const cur = s.data();
      tx.update(ref, {
        sa: cur.sa + (side === 'a' ? 1 : 0),
        sb: cur.sb + (side === 'b' ? 1 : 0),
        lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
      });
    });
    toast('Score added', metaTitle);
  };

  const onReset = async (id, metaTitle) => {
    const ref = coll().doc(id);
    const snap = await ref.get();
    if (!snap.exists) return;
    const d = snap.data();
    const { armed, rem, ready } = resetState(d);

    // Tap 1 → arm
    if (!armed) {
      await ref.update({ resetArmAt: firebase.firestore.FieldValue.serverTimestamp() });
      return toast('Reset armed. Come back in 10 minutes, then tap Reset again to confirm.', metaTitle);
    }
    // Armed but still counting down
    if (!ready) {
      return toast(`Reset armed — ${human(rem)} left before you can confirm.`, metaTitle);
    }
    // Tap 2 after 10 min → perform reset
    await db.runTransaction(async (tx) => {
      const s = await tx.get(ref); if (!s.exists) throw new Error('missing');
      tx.update(ref, { sa: 0, sb: 0, lastUpdate: null, resetArmAt: null });
    });
    toast('Reset complete', metaTitle);
  };

  const onDelete = async (id, metaTitle) => {
    const ref = coll().doc(id);
    const snap = await ref.get();
    if (!snap.exists) return;
    const d = snap.data();
    const { armed, rem, ready } = deleteState(d);

    // Tap 1 → arm
    if (!armed) {
      await ref.update({ deleteArmAt: firebase.firestore.FieldValue.serverTimestamp() });
      return toast('Delete armed. Come back in 10 minutes, then tap Delete again to confirm.', metaTitle);
    }
    // Armed but still counting down
    if (!ready) {
      return toast(`Delete armed — ${human(rem)} left before you can confirm.`, metaTitle);
    }
    // Tap 2 after 10 min → delete
    await ref.delete();
    toast('Matchup deleted', metaTitle);
  };

  const rename = async (id, side, name) => {
    if (!name || !name.trim()) return;
    await coll().doc(id).update(side === 'a' ? { a: name.trim() } : { b: name.trim() });
  };

  /* === UI: cards, badges, live view === */

  const card = (it) => {
    const scoreRem = remainingScore(it);
    const scoreReady = scoreRem === 0;

    const rSt = resetState(it);
    const dSt = deleteState(it);

    const resetBadge = !rSt.armed
      ? `<span class="badge">Reset: Tap to arm</span>`
      : (rSt.ready
          ? `<span class="badge ok">Reset: Ready to confirm</span>`
          : `<span class="badge wait">Reset: Armed — Wait ${human(rSt.rem)}</span>`);

    const deleteBadge = !dSt.armed
      ? `<span class="badge">Delete: Tap to arm</span>`
      : (dSt.ready
          ? `<span class="badge ok">Delete: Ready to confirm</span>`
          : `<span class="badge wait">Delete: Armed — Wait ${human(dSt.rem)}</span>`);

    const lead = it.sa === it.sb ? 'Tied' : (it.sa > it.sb ? `${it.a} leading` : `${it.b} leading`);

    return `
    <div class="card" data-id="${it.id}">
      <div class="row">
        <div>
          <div class="vs">
            <span class="name editable" data-side="a">${it.a}</span> vs
            <span class="name editable" data-side="b">${it.b}</span>
          </div>
          ${it.title ? `<div class="subtitle">${it.title}</div>` : ''}
        </div>
        <div class="toolbar">
          <span class="badge">${lead}</span>
          ${scoreReady ? `<span class="badge ok">Score: Ready</span>` : `<span class="badge wait">Score: Wait ${human(scoreRem)}</span>`}
          ${resetBadge}
          ${deleteBadge}
        </div>
      </div>
      <div class="row">
        <div class="score">${it.sa} : ${it.sb}</div>
        <div class="controls">
          <button class="button" data-action="plusA" ${scoreReady ? '' : 'disabled'}>+1 ${it.a}</button>
          <button class="button" data-action="plusB" ${scoreReady ? '' : 'disabled'}>+1 ${it.b}</button>
        </div>
      </div>
      <div class="row">
        <div class="small">Last score add: ${it.lastUpdate ? it.lastUpdate.toDate().toLocaleString() : "—"}</div>
        <div class="controls">
          <button class="button secondary" data-action="reset">Reset</button>
          <button class="button secondary" data-action="delete">Delete</button>
        </div>
      </div>
    </div>`;
  };

  let unsubscribe = null;

  const render = (docs) => {
    const q = $('#search').value.trim().toLowerCase();
    const items = docs
      .filter(x => !q || x.a.toLowerCase().includes(q) || x.b.toLowerCase().includes(q) || (x.title||'').toLowerCase().includes(q))
      .sort((x,y)=> (y.createdMs||0) - (x.createdMs||0));

    $('#list').innerHTML = items.map(card).join('');
    $('#empty').style.display = items.length ? 'none' : 'block';

    $$('#list .card').forEach(el => {
      const id = el.getAttribute('data-id');
      const title = el.querySelector('.subtitle')?.textContent || '';

      el.querySelector('[data-action="plusA"]').addEventListener('click', ()=> bump(id, 'a', title));
      el.querySelector('[data-action="plusB"]').addEventListener('click', ()=> bump(id, 'b', title));
      el.querySelector('[data-action="reset"]').addEventListener('click', ()=> onReset(id, title));
      el.querySelector('[data-action="delete"]').addEventListener('click', ()=> onDelete(id, title));

      el.querySelectorAll('.editable').forEach(n=>{
        n.addEventListener('click', ()=>{
          const side = n.getAttribute('data-side');
          const next = prompt('Rename', n.textContent);
          if (next) rename(id, side, next);
        });
      });
    });
  };

  const listen = () => {
    if (unsubscribe) unsubscribe();
    unsubscribe = coll().orderBy('created','desc').onSnapshot((snap) => {
      const docs = [];
      snap.forEach(d => {
        const x = d.data();
        docs.push({
          id: d.id,
          a: x.a, b: x.b, title: x.title || '',
          sa: x.sa, sb: x.sb,
          created: x.created || null,
          createdMs: x.created ? x.created.toMillis() : 0,
          lastUpdate: x.lastUpdate || null,
          resetArmAt: x.resetArmAt || null,
          deleteArmAt: x.deleteArmAt || null
        });
      });
      render(docs);
    });
  };

  /* === Wire up === */
  $('#add').addEventListener('click', addMatchup);
  $('#a,#b,#t').addEventListener('keydown', (e)=>{ if (e.key==='Enter') addMatchup(); });
  $('#search').addEventListener('input', listen);

  listen();
  // light polling to refresh countdown badges every second
  setInterval(listen, 1000);
</script>
</body>
</html>
